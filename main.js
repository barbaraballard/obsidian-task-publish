/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var R=Object.create;var m=Object.defineProperty;var A=Object.getOwnPropertyDescriptor;var O=Object.getOwnPropertyNames;var B=Object.getPrototypeOf,L=Object.prototype.hasOwnProperty;var U=(c,t)=>{for(var e in t)m(c,e,{get:t[e],enumerable:!0})},I=(c,t,e,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of O(t))!L.call(c,n)&&n!==e&&m(c,n,{get:()=>t[n],enumerable:!(s=A(t,n))||s.enumerable});return c};var $=(c,t,e)=>(e=c!=null?R(B(c)):{},I(t||!c||!c.__esModule?m(e,"default",{value:c,enumerable:!0}):e,c)),M=c=>I(m({},"__esModule",{value:!0}),c);var j={};U(j,{default:()=>b});module.exports=M(j);var r=require("obsidian");var v={publishPagePath:"Daily Tasks.md",periodicNotesFolder:"Daily Notes",syncInterval:60,pagePassword:"",gitRepoUrl:"",gitBranch:"main",localRepoPath:"",lastSync:0};var f=class{constructor(t,e){this.app=t,this.settings=e}async processTaskQueries(t){let e=/```tasks\n([\s\S]*?)\n```/g,s=t,n;for(;(n=e.exec(t))!==null;){let i=n[1],a=await this.executeTaskQuery(i),o=this.renderTasksAsHtml(a,i);s=s.replace(n[0],o)}return s}async executeTaskQuery(t){let e=await this.getAllTasks();return this.filterTasks(e,t)}async getAllTasks(){let t=[],e=this.app.vault.getMarkdownFiles();for(let s of e){let n=await this.app.vault.read(s),i=this.extractTasksFromContent(n,s.path);t.push(...i)}return t}extractTasksFromContent(t,e){let s=[];return t.split(`
`).forEach((i,a)=>{let o=i.match(/^(\s*)-\s*\[([ x])\]\s*(.+)$/);if(o){let[,l,d,p]=o,h=d==="x",T=this.extractPriority(p),P=this.extractDate(p,"\u{1F4C5}"),x=this.extractDate(p,"\u23F3"),E=this.extractDate(p,"\u{1F6EB}"),F={id:`${e}:${a}`,text:this.cleanTaskText(p),completed:h,priority:T,dueDate:P,scheduledDate:x,startDate:E,filePath:e,lineNumber:a};s.push(F)}}),s}extractPriority(t){let e=t.match(/[⏫🔺🔼🔽]/);if(!e)return"none";switch(e[0]){case"\u23EB":return"highest";case"\u{1F53A}":return"high";case"\u{1F53C}":return"medium";case"\u{1F53D}":return"low";default:return"none"}}extractDate(t,e){let s=new RegExp(`${e}\\s*(\\d{4}-\\d{2}-\\d{2})`),n=t.match(s);return n?n[1]:void 0}cleanTaskText(t){return t.replace(/[⏫🔺🔼🔽]/g,"").replace(/📅\s*\d{4}-\d{2}-\d{2}/g,"").replace(/⏳\s*\d{4}-\d{2}-\d{2}/g,"").replace(/🛫\s*\d{4}-\d{2}-\d{2}/g,"").trim()}filterTasks(t,e){let s=new Date().toISOString().split("T")[0],n=new Date(Date.now()+24*60*60*1e3).toISOString().split("T")[0];return t.filter(i=>{let a=e.toLowerCase().split(`
`).map(o=>o.trim());for(let o of a){if(o.includes("not done")&&i.completed||o.includes("done today")&&(!i.completed||!this.isCompletedToday(i))||o.includes("starts before tomorrow")&&i.startDate&&i.startDate>=n||o.includes("due on or before tomorrow")&&i.dueDate&&i.dueDate>n||o.includes("scheduled before tomorrow")&&i.scheduledDate&&i.scheduledDate>=n||o.includes("priority is above medium")&&!["high","highest"].includes(i.priority)||o.includes("priority is medium")&&i.priority!=="medium"||o.includes("due after today")&&i.dueDate&&i.dueDate<=s)return!1;if(o.includes("due within 3 days")&&i.dueDate){let l=new Date(Date.now()+2592e5).toISOString().split("T")[0];if(i.dueDate>l)return!1}}return!0})}isCompletedToday(t){return t.completed}renderTasksAsHtml(t,e){let s=e.includes("short mode"),n=e.includes("hide task count"),i='<div class="task-group">';return n||(i+=`<div class="task-count">${t.length} tasks</div>`),t.forEach(a=>{let o=a.priority!=="none"?`priority-${a.priority}`:"",l=a.completed?"completed":"";i+=`
                <div class="task-item ${o} ${l}" data-task-id="${a.id}">
                    <input type="checkbox" ${a.completed?"checked":""} data-task-id="${a.id}" onchange="toggleTask('${a.id}')">
                    <span class="task-text">${a.text}</span>
                    ${s?"":this.renderTaskMetadata(a)}
                    <div class="task-actions">
                        <button onclick="postponeTask('${a.id}', 1)">+1d</button>
                        <button onclick="postponeTask('${a.id}', 7)">+1w</button>
                    </div>
                </div>
            `}),i+="</div>",i}renderTaskMetadata(t){let e="";return t.dueDate&&(e+=`<span class="due-date">\u{1F4C5} ${t.dueDate}</span>`),t.scheduledDate&&(e+=`<span class="scheduled-date">\u23F3 ${t.scheduledDate}</span>`),t.startDate&&(e+=`<span class="start-date">\u{1F6EB} ${t.startDate}</span>`),t.priority!=="none"&&(e+=`<span class="priority">${this.getPrioritySymbol(t.priority)}</span>`),e?`<div class="task-metadata">${e}</div>`:""}getPrioritySymbol(t){switch(t){case"highest":return"\u23EB";case"high":return"\u{1F53A}";case"medium":return"\u{1F53C}";case"low":return"\u{1F53D}";default:return""}}};var C=require("child_process"),N=require("util"),S=$(require("path")),y=$(require("fs")),g=(0,N.promisify)(C.exec),k=class{constructor(t){this.settings=t}async publish(t){let e=this.generateHtmlPage(t);if(!this.settings.gitRepoUrl)throw new Error("Git repository URL is required for publishing");await this.publishToGitHub(e)}async publishToGitHub(t){let e=this.settings.localRepoPath||S.join(process.cwd(),".taskpublish-repo");try{y.existsSync(e)||(console.log("Cloning repository..."),await g(`git clone ${this.settings.gitRepoUrl} "${e}"`)),process.chdir(e),await g("git pull origin "+this.settings.gitBranch);let s=S.join(e,"index.html");y.writeFileSync(s,t,"utf8");let{stdout:n}=await g("git status --porcelain");n.trim()?(await g("git add index.html"),await g(`git commit -m "Update tasks - ${new Date().toISOString()}"`),await g(`git push origin ${this.settings.gitBranch}`),console.log("Tasks published to GitHub successfully!")):console.log("No changes to publish")}catch(s){throw console.error("Error publishing to GitHub:",s),new Error(`GitHub publishing failed: ${s}`)}}generateHtmlPage(t){let e=this.settings.pagePassword?this.generatePasswordProtection():"";return`
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Tasks</title>
    <style>
        ${this.getStyles()}
    </style>
</head>
<body>
    ${e}
    <div id="main-content" ${this.settings.pagePassword?'style="display:none"':""}>
        <div class="container">
            <h1>My Tasks</h1>
            <div class="last-updated">Last updated: ${new Date().toLocaleString()}</div>
            <div class="repo-info">\u{1F4C1} Published from: ${this.settings.gitRepoUrl}</div>
            
            <div class="task-input-section">
                <h3>Add New Task</h3>
                <input type="text" id="new-task-input" placeholder="Enter a new task..." />
                <button onclick="addNewTask()">Add Task</button>
            </div>
            
            <div class="content">
                ${t}
            </div>
        </div>
    </div>
    
    <script>
        ${this.getJavaScript()}
    <\/script>
</body>
</html>`}generatePasswordProtection(){return`
        <div id="password-prompt" class="password-screen">
            <div class="password-container">
                <h2>Enter Password</h2>
                <input type="password" id="password-input" placeholder="Password" />
                <button onclick="checkPassword()">Enter</button>
            </div>
        </div>`}getStyles(){return`
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: white;
            min-height: 100vh;
        }
        
        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        
        .last-updated, .repo-info {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 15px;
        }
        
        .repo-info {
            background: #f8f9fa;
            padding: 8px 12px;
            border-radius: 4px;
            border-left: 4px solid #28a745;
            margin-bottom: 30px;
        }
        
        .task-input-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
        }
        
        .task-input-section h3 {
            margin-bottom: 15px;
            color: #2c3e50;
        }
        
        #new-task-input {
            width: 70%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
        }
        
        button {
            padding: 10px 20px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 10px;
        }
        
        button:hover {
            background: #2980b9;
        }
        
        .task-group {
            margin-bottom: 30px;
        }
        
        .task-count {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 10px;
        }
        
        .task-item {
            display: flex;
            align-items: center;
            padding: 12px;
            border: 1px solid #e1e5e9;
            border-radius: 6px;
            margin-bottom: 8px;
            background: white;
            transition: all 0.2s ease;
        }
        
        .task-item:hover {
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .task-item.completed {
            opacity: 0.6;
            background: #f8f9fa;
        }
        
        .task-item.completed .task-text {
            text-decoration: line-through;
        }
        
        .task-item input[type="checkbox"] {
            margin-right: 12px;
            transform: scale(1.2);
        }
        
        .task-text {
            flex: 1;
            font-size: 16px;
        }
        
        .task-metadata {
            display: flex;
            gap: 10px;
            margin-left: 10px;
            font-size: 0.85em;
        }
        
        .task-metadata span {
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 3px;
        }
        
        .due-date { background: #fff3cd; }
        .scheduled-date { background: #d1ecf1; }
        .start-date { background: #d4edda; }
        .priority { background: #f8d7da; }
        
        .task-actions {
            display: flex;
            gap: 5px;
            margin-left: 10px;
        }
        
        .task-actions button {
            padding: 4px 8px;
            font-size: 0.8em;
            margin: 0;
        }
        
        .priority-highest { border-left: 4px solid #dc3545; }
        .priority-high { border-left: 4px solid #fd7e14; }
        .priority-medium { border-left: 4px solid #ffc107; }
        .priority-low { border-left: 4px solid #6c757d; }
        
        .password-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #f5f5f5;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .password-container {
            background: white;
            padding: 40px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .password-container h2 {
            margin-bottom: 20px;
            color: #2c3e50;
        }
        
        .password-container input {
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 20px;
            width: 200px;
            font-size: 16px;
        }
        
        @media (max-width: 600px) {
            .container {
                padding: 10px;
            }
            
            #new-task-input {
                width: 100%;
                margin-bottom: 10px;
            }
            
            button {
                margin-left: 0;
                width: 100%;
            }
            
            .task-item {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .task-actions {
                margin-left: 0;
                margin-top: 10px;
            }
        }`}getJavaScript(){return`
        let pendingChanges = {
            toggles: {},
            postpones: {},
            newTasks: {}
        };
        
        function checkPassword() {
            const input = document.getElementById('password-input');
            const enteredPassword = input.value;
            const correctPassword = '${this.settings.pagePassword}';
            
            if (enteredPassword === correctPassword) {
                document.getElementById('password-prompt').style.display = 'none';
                document.getElementById('main-content').style.display = 'block';
            } else {
                alert('Incorrect password');
                input.value = '';
            }
        }
        
        function toggleTask(taskId) {
            // Store in pending changes object
            pendingChanges.toggles[taskId] = true;
            savePendingChanges();
            
            // Update UI immediately
            const checkbox = document.querySelector('input[data-task-id="' + taskId + '"]');
            if (checkbox) {
                const taskItem = checkbox.closest('.task-item');
                if (checkbox.checked) {
                    taskItem.classList.add('completed');
                } else {
                    taskItem.classList.remove('completed');
                }
            }
            
            console.log('Task toggle queued for next Obsidian sync');
        }
        
        function postponeTask(taskId, days) {
            const newDate = new Date();
            newDate.setDate(newDate.getDate() + days);
            const dateString = newDate.toISOString().split('T')[0];
            
            pendingChanges.postpones[taskId] = dateString;
            savePendingChanges();
            
            alert('Task postponed to ' + dateString + '. Will sync on next Obsidian startup.');
        }
        
        function addNewTask() {
            const input = document.getElementById('new-task-input');
            const taskText = input.value.trim();
            
            if (taskText) {
                const timestamp = Date.now();
                pendingChanges.newTasks[timestamp] = taskText;
                savePendingChanges();
                
                input.value = '';
                alert('Task queued for next sync!');
            }
        }
        
        function savePendingChanges() {
            // In a real implementation, this would save to a JSON file
            // that gets committed to the repository
            // For now, we'll use localStorage as a fallback
            localStorage.setItem('taskpublish_pending_changes', JSON.stringify(pendingChanges));
            console.log('Pending changes saved:', pendingChanges);
        }
        
        function loadPendingChanges() {
            const saved = localStorage.getItem('taskpublish_pending_changes');
            if (saved) {
                pendingChanges = JSON.parse(saved);
            }
        }
        
        // Handle Enter key in password input
        document.addEventListener('DOMContentLoaded', function() {
            loadPendingChanges();
            
            const passwordInput = document.getElementById('password-input');
            if (passwordInput) {
                passwordInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        checkPassword();
                    }
                });
            }
            
            const taskInput = document.getElementById('new-task-input');
            if (taskInput) {
                taskInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        addNewTask();
                    }
                });
            }
        });`}};var u=require("obsidian"),w=class{constructor(t,e){this.app=t,this.settings=e}async sync(){try{await this.readPendingChangesFromRepo(),this.settings.lastSync=Date.now(),console.log("Task sync completed successfully")}catch(t){throw console.error("Error during task sync:",t),t}}async processPendingWebChanges(){let t=this.getPendingToggles(),e=this.getPendingPostpones(),s=this.getPendingTasks();for(let[n,i]of Object.entries(t))await this.toggleTaskInVault(n);for(let[n,i]of Object.entries(e))await this.postponeTaskInVault(n,i);for(let[n,i]of Object.entries(s))await this.addTaskToPeriodicNote(i);this.clearProcessedPendingChanges()}async toggleTaskInVault(t){let[e,s]=t.split(":"),n=this.app.vault.getAbstractFileByPath(e);if(!n||!(n instanceof u.TFile)){console.warn(`File not found: ${e}`);return}let a=(await this.app.vault.read(n)).split(`
`),o=parseInt(s);if(o>=0&&o<a.length){let d=a[o].match(/^(\s*)-\s*\[([ x])\]\s*(.+)$/);if(d){let[,p,h,T]=d,P=h==="x"?" ":"x";a[o]=`${p}- [${P}] ${T}`;let x=a.join(`
`);await this.app.vault.modify(n,x),console.log(`Toggled task: ${t}`)}}}async postponeTaskInVault(t,e){let[s,n]=t.split(":"),i=this.app.vault.getAbstractFileByPath(s);if(!i||!(i instanceof u.TFile)){console.warn(`File not found: ${s}`);return}let o=(await this.app.vault.read(i)).split(`
`),l=parseInt(n);if(l>=0&&l<o.length){let d=o[l];d=d.replace(/📅\s*\d{4}-\d{2}-\d{2}/,"").trim(),d.endsWith("]")?d=d.slice(0,-1)+` \u{1F4C5} ${e}]`:d+=` \u{1F4C5} ${e}`,o[l]=d;let p=o.join(`
`);await this.app.vault.modify(i,p),console.log(`Postponed task ${t} to ${e}`)}}async addTaskToPeriodicNote(t){let s=new Date().toISOString().split("T")[0],n=`${s}.md`,i=`${this.settings.periodicNotesFolder}/${n}`,a=this.app.vault.getAbstractFileByPath(i);if(!a||!(a instanceof u.TFile))try{a=await this.app.vault.create(i,this.getDefaultDailyNoteTemplate(s))}catch(o){if(console.error(`Error creating daily note: ${o}`),this.app.vault.getAbstractFileByPath(this.settings.periodicNotesFolder)){let d=this.app.vault.getMarkdownFiles().filter(p=>p.path.startsWith(this.settings.periodicNotesFolder)).sort((p,h)=>h.stat.mtime-p.stat.mtime);if(d.length>0)a=d[0];else throw new Error("No periodic notes found")}else throw new Error("Periodic notes folder not found")}if(a instanceof u.TFile){let o=await this.app.vault.read(a),l=`- [ ] ${t}`,d;o.includes("## Tasks")||o.includes("# Tasks")?d=o.replace(/(## Tasks|# Tasks)/,`$1
${l}`):d=o+`

## Tasks
${l}`,await this.app.vault.modify(a,d),console.log(`Added new task: ${t}`)}}getDefaultDailyNoteTemplate(t){return`# ${t}

## Tasks
- [ ] Review daily tasks

## Notes

`}getPendingToggles(){return{}}getPendingPostpones(){return{}}getPendingTasks(){return{}}clearProcessedPendingChanges(){console.log("Cleared processed pending changes")}async readPendingChangesFromRepo(){let e=`${this.settings.localRepoPath||".taskpublish-repo"}/pending-changes.json`;try{let s=require("fs");if(s.existsSync(e)){let n=JSON.parse(s.readFileSync(e,"utf8"));for(let[i,a]of Object.entries(n.toggles||{}))await this.toggleTaskInVault(i);for(let[i,a]of Object.entries(n.postpones||{}))await this.postponeTaskInVault(i,a);for(let[i,a]of Object.entries(n.newTasks||{}))await this.addTaskToPeriodicNote(a);s.unlinkSync(e),console.log("Processed and cleared pending changes from repository")}}catch(s){console.error("Error reading pending changes from repository:",s)}}async findModifiedTasks(){let t=[],e=this.app.vault.getMarkdownFiles();for(let s of e)if(s.stat.mtime>this.settings.lastSync){let n=await this.app.vault.read(s);this.containsTasks(n)&&t.push(s.path)}return t}containsTasks(t){return/^[\s]*-\s*\[[ x]\]/m.test(t)}async setupRealTimeSync(){console.log("Real-time sync setup - would implement WebSocket connection")}};var b=class extends r.Plugin{constructor(){super(...arguments);this.settings=v}async onload(){await this.loadSettings(),this.taskProcessor=new f(this.app,this.settings),this.webPublisher=new k(this.settings),this.taskSyncer=new w(this.app,this.settings),this.addRibbonIcon("upload","Publish Tasks",()=>{this.publishTasks()}),this.addCommand({id:"publish-tasks",name:"Publish Tasks",callback:()=>this.publishTasks()}),this.addCommand({id:"sync-tasks",name:"Sync Tasks",callback:()=>this.syncTasks()}),this.addSettingTab(new D(this.app,this)),this.setupAutoSync(),setTimeout(()=>this.syncTasks(),2e3)}onunload(){this.syncInterval&&window.clearInterval(this.syncInterval)}async loadSettings(){this.settings=Object.assign({},v,await this.loadData())}async saveSettings(){await this.saveData(this.settings),this.setupAutoSync()}setupAutoSync(){this.syncInterval&&window.clearInterval(this.syncInterval),this.settings.syncInterval>0&&(this.syncInterval=window.setInterval(()=>{this.syncTasks()},this.settings.syncInterval*60*1e3))}async publishTasks(){try{let e=this.app.vault.getAbstractFileByPath(this.settings.publishPagePath);if(!e||!(e instanceof r.TFile)){new r.Notice("Publish page not found. Please check your settings.");return}let s=await this.app.vault.read(e),n=await this.taskProcessor.processTaskQueries(s);await this.webPublisher.publish(n),new r.Notice("Tasks published successfully!")}catch(e){console.error("Error publishing tasks:",e),new r.Notice("Error publishing tasks. Check console for details.")}}async syncTasks(){try{await this.taskSyncer.sync(),new r.Notice("Tasks synced successfully!")}catch(e){console.error("Error syncing tasks:",e),new r.Notice("Error syncing tasks. Check console for details.")}}},D=class extends r.PluginSettingTab{constructor(t,e){super(t,e),this.plugin=e}display(){let{containerEl:t}=this;t.empty(),t.createEl("h2",{text:"TaskPublish Settings"}),new r.Setting(t).setName("Publish Page Path").setDesc("Path to the page containing task queries to publish").addText(e=>e.setPlaceholder("Daily Tasks.md").setValue(this.plugin.settings.publishPagePath).onChange(async s=>{this.plugin.settings.publishPagePath=s,await this.plugin.saveSettings()})),new r.Setting(t).setName("Periodic Notes Folder").setDesc("Folder where new tasks should be added (usually Daily Notes)").addText(e=>e.setPlaceholder("Daily Notes").setValue(this.plugin.settings.periodicNotesFolder).onChange(async s=>{this.plugin.settings.periodicNotesFolder=s,await this.plugin.saveSettings()})),new r.Setting(t).setName("Sync Interval (minutes)").setDesc("How often to sync tasks (0 to disable)").addText(e=>e.setPlaceholder("60").setValue(this.plugin.settings.syncInterval.toString()).onChange(async s=>{let n=parseInt(s);!isNaN(n)&&n>=0&&(this.plugin.settings.syncInterval=n,await this.plugin.saveSettings())})),new r.Setting(t).setName("Page Password/PIN").setDesc("Password or PIN to protect the published page").addText(e=>e.setPlaceholder("Enter password").setValue(this.plugin.settings.pagePassword).onChange(async s=>{this.plugin.settings.pagePassword=s,await this.plugin.saveSettings()})),new r.Setting(t).setName("Git Repository URL").setDesc("URL of your private GitHub repository (e.g., https://github.com/username/my-tasks.git)").addText(e=>e.setPlaceholder("https://github.com/username/my-tasks.git").setValue(this.plugin.settings.gitRepoUrl).onChange(async s=>{this.plugin.settings.gitRepoUrl=s,await this.plugin.saveSettings()})),new r.Setting(t).setName("Git Branch").setDesc("Branch to publish to (usually main or gh-pages)").addText(e=>e.setPlaceholder("main").setValue(this.plugin.settings.gitBranch).onChange(async s=>{this.plugin.settings.gitBranch=s,await this.plugin.saveSettings()})),new r.Setting(t).setName("Local Repository Path").setDesc("Local path where the git repository will be cloned (optional)").addText(e=>e.setPlaceholder("/path/to/local/repo").setValue(this.plugin.settings.localRepoPath).onChange(async s=>{this.plugin.settings.localRepoPath=s,await this.plugin.saveSettings()}))}};
